<!-- doc/src/sgml/gist.sgml -->

<chapter id="GiST">
<!--
<title>GiST Indexes</title>
-->
<Title>GiSTインデックス</Title>

   <indexterm>
<!--
    <primary>index</primary>
-->
    <primary>インデックス</primary>
    <secondary>GiST</secondary>
   </indexterm>

<sect1 id="gist-intro">
<!--
 <title>Introduction</title>
-->
 <title>序文</title>

 <para>
<!--
   <acronym>GiST</acronym> stands for Generalized Search Tree.  It is a
   balanced, tree-structured access method, that acts as a base template in
   which to implement arbitrary indexing schemes. B-trees, R-trees and many
   other indexing schemes can be implemented in <acronym>GiST</acronym>.
-->
<acronym>GiST</acronym>は汎用検索ツリー（Generalized Search Tree）を表します。
これは、均衡な、ツリー構造のアクセスメソッドで、任意のインデックスの枠組みを実装する基本的なテンプレートとして動作します。
B-tree、R-treeやその他多くのインデックスの枠組みを<acronym>GiST</acronym>で実装することができます。
 </para>

 <para>
<!--
  One advantage of <acronym>GiST</acronym> is that it allows the development
  of custom data types with the appropriate access methods, by
  an expert in the domain of the data type, rather than a database expert.
-->
<acronym>GiST</acronym>の利点の1つは、データベースの専門家ではなく、データ型分野の専門家によって、適切なアクセスメソッドで独自のデータ型を開発することができることです。
 </para>

  <para>
<!--
    Some of the information here is derived from the University of California
    at Berkeley's GiST Indexing Project
    <ulink url="http://gist.cs.berkeley.edu/">web site</ulink> and
    Marcel Kornacker's thesis,
    <ulink url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">
    Access Methods for Next-Generation Database Systems</ulink>.
    The <acronym>GiST</acronym>
    implementation in <productname>PostgreSQL</productname> is primarily
    maintained by Teodor Sigaev and Oleg Bartunov, and there is more
    information on their
    <ulink url="http://www.sai.msu.su/~megera/postgres/gist/">web site</ulink>.
-->
ここで示す情報の一部は、カリフォルニア大学バークレイ校のGiSTインデックスプロジェクト、<ulink url="http://gist.cs.berkeley.edu/">web site</ulink>およびMarcel Kornackerの論文、<ulink url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">Access Methods for Next-Generation Database Systems</ulink>から派生したものです。
<productname>PostgreSQL</productname>における<acronym>GiST</acronym>の実装は、主に、Teodor SigaevとOleg Bartunovによって保守されています。
そして、彼らの<ulink url="http://www.sai.msu.su/~megera/postgres/gist/">ウェブサイト</>にも多くの情報があります。
  </para>

</sect1>

<sect1 id="gist-extensibility">
<!--
 <title>Extensibility</title>
-->
 <title>拡張性</title>

 <para>
<!--
   Traditionally, implementing a new index access method meant a lot of
   difficult work.  It was necessary to understand the inner workings of the
   database, such as the lock manager and Write-Ahead Log.  The
   <acronym>GiST</acronym> interface has a high level of abstraction,
   requiring the access method implementer only to implement the semantics of
   the data type being accessed.  The <acronym>GiST</acronym> layer itself
   takes care of concurrency, logging and searching the tree structure.
-->
伝統的に、新しいインデックスメソッドの実装は、非常に難しい作業を意味していました。
ロックマネージャやログ先行書き込みなどデータベースの内部動作を理解する必要がありました。
<acronym>GiST</acronym>インタフェースは高度に抽象化されており、アクセスメソッドの実装者には、アクセスするデータ型のセマンティックスのみの実装を要求します。
<acronym>GiST</acronym>層自身が同時実行性、ログ処理、ツリー構造の検索処理に関する注意を行います。
 </para>

 <para>
<!--
   This extensibility should not be confused with the extensibility of the
   other standard search trees in terms of the data they can handle.  For
   example, <productname>PostgreSQL</productname> supports extensible B-trees
   and hash indexes. That means that you can use
   <productname>PostgreSQL</productname> to build a B-tree or hash over any
   data type you want. But B-trees only support range predicates
   (<literal>&lt;</literal>, <literal>=</literal>, <literal>&gt;</literal>),
   and hash indexes only support equality queries.
-->
この拡張性と、他の、扱うことができるデータを対象とした標準検索ツリーの拡張性とを混同すべきではありません。
例えば、<productname>PostgreSQL</productname>は拡張可能なB-treeとハッシュインデックスをサポートしています。
これは、<productname>PostgreSQL</productname>を使用して、任意のデータ型に対するB-treeやハッシュを構築することができることを意味します。
しかし、B-treeは範囲述語（<literal>&lt;</literal>、<literal>=</literal>、<literal>&gt;</literal>）のみをサポートし、ハッシュインデックスは等価性問い合わせのみをサポートします。
 </para>

 <para>
<!--
   So if you index, say, an image collection with a
   <productname>PostgreSQL</productname> B-tree, you can only issue queries
   such as <quote>is imagex equal to imagey</quote>, <quote>is imagex less
   than imagey</quote> and <quote>is imagex greater than imagey</quote>.
   Depending on how you define <quote>equals</quote>, <quote>less than</quote>
   and <quote>greater than</quote> in this context, this could be useful.
   However, by using a <acronym>GiST</acronym> based index, you could create
   ways to ask domain-specific questions, perhaps <quote>find all images of
   horses</quote> or <quote>find all over-exposed images</quote>.
-->
ですから、<productname>PostgreSQL</productname>のB-treeで例えば画像群をインデックス付けする場合、<quote>画像xは画像yと同じか</quote>、<quote>画像xは画像yより小さいか</quote>、<quote>画像xは画像yより大きいか</quote>といった問い合わせのみ発行することができます。
この文脈でどのように<quote>同じか</quote>や<quote>より小さいか</quote>、<quote>より大きいか</quote>を定義するかに依存して、これが有意なこともあるでしょう。
しかし、<acronym>GiST</acronym>を基にしたインデックスを使用すれば、問題分野に特化した、おそらくは、<quote>馬の画像を全て見つけたい</quote>、<quote>露出オーバーの写真をすべて見つけたい</quote>といった質問に答えられる手段を作成することができます。
 </para>

 <para>
<!--
   All it takes to get a <acronym>GiST</acronym> access method up and running
   is to implement several user-defined methods, which define the behavior of
   keys in the tree. Of course these methods have to be pretty fancy to
   support fancy queries, but for all the standard queries (B-trees,
   R-trees, etc.) they're relatively straightforward. In short,
   <acronym>GiST</acronym> combines extensibility along with generality, code
   reuse, and a clean interface.
-->
<acronym>GiST</acronym>アクセスメソッドを有効にし、実行するために行なわなければならないことは、ツリーのキーの動作を定義する、複数のユーザ定義のメソッドを実装することです。
当然ながら、これらのメソッドは手の込んだ問い合わせをサポートするためかなり意匠を凝らす必要があります。
しかし、すべての標準的な問い合わせ（B-treeやR-treeなど）ではこれらは、相対的に見てごく簡単です。
まとめると、<acronym>GiST</acronym>は汎用性、コード再利用、整理されたインタフェースと拡張性を兼ね備えたものです。
  </para>

 <para>
<!--
   There are seven methods that an index operator class for
   <acronym>GiST</acronym> must provide, and an eighth that is optional.
   Correctness of the index is ensured
   by proper implementation of the <function>same</>, <function>consistent</>
   and <function>union</> methods, while efficiency (size and speed) of the
   index will depend on the <function>penalty</> and <function>picksplit</>
   methods.
   The remaining two basic methods are <function>compress</> and
   <function>decompress</>, which allow an index to have internal tree data of
   a different type than the data it indexes. The leaves are to be of the
   indexed data type, while the other tree nodes can be of any C struct (but
   you still have to follow <productname>PostgreSQL</> data type rules here,
   see about <literal>varlena</> for variable sized data). If the tree's
   internal data type exists at the SQL level, the <literal>STORAGE</> option
   of the <command>CREATE OPERATOR CLASS</> command can be used.
   The optional eighth method is <function>distance</>, which is needed
   if the operator class wishes to support ordered scans (nearest-neighbor
   searches).
-->
<acronym>GiST</acronym>用の演算子クラスが提供しなければならない７つのメソッドを以下に示します。
８番目は省略可能です。
インデックスの正確性は、確実に<function>same</>、<function>consistent</>、<function>union</>メソッドを適切に実装することです。
一方、インデックスの効率（容量と速度）は<function>penalty</>と<function>picksplit</>メソッドに依存します。
残る２つの基本メソッドは<function>compress</>と<function>decompress</>ですが、これによりインデックスはインデックス付けするデータと異なるデータ型のツリーデータを内部で持つことができるようになります。
リーフはインデックス付けするデータ型となりますが、他のツリーノードは何らかのC構造体を取ることができます。
（しかしここでも<productname>PostgreSQL</>のデータ型規約に従わなければなりません。
容量が可変のデータに関しては<literal>varlena</>を参照してください。）
ツリーの内部データ型がSQLレベルで存在する場合、<command>CREATE OPERATOR CLASS</>コマンドの<literal>STORAGE</>オプションを使用することができます。
省略可能な８番目のメソッドは<function>distance</>です。
これは演算子クラスに順序付けスキャン（近傍検索）をサポートさせたい場合に必要です。
 </para>

 <variablelist>
    <varlistentry>
     <term><function>consistent</></term>
     <listitem>
      <para>
<!--
       Given an index entry <literal>p</> and a query value <literal>q</>,
       this function determines whether the index entry is
       <quote>consistent</> with the query; that is, could the predicate
       <quote><replaceable>indexed_column</>
       <replaceable>indexable_operator</> <literal>q</></quote> be true for
       any row represented by the index entry?  For a leaf index entry this is
       equivalent to testing the indexable condition, while for an internal
       tree node this determines whether it is necessary to scan the subtree
       of the index represented by the tree node.  When the result is
       <literal>true</>, a <literal>recheck</> flag must also be returned.
       This indicates whether the predicate is certainly true or only possibly
       true.  If <literal>recheck</> = <literal>false</> then the index has
       tested the predicate condition exactly, whereas if <literal>recheck</>
       = <literal>true</> the row is only a candidate match.  In that case the
       system will automatically evaluate the
       <replaceable>indexable_operator</> against the actual row value to see
       if it is really a match.  This convention allows
       <acronym>GiST</acronym> to support both lossless and lossy index
       structures.
-->
インデックス項目<literal>p</>と問い合わせ値<literal>q</>が与えられると、この関数はインデックス項目が問い合わせと<quote>一貫性</>があるかどうか、つまり、述語<quote><replaceable>indexed_column</><replaceable>indexable_operator</> <literal>q</></quote>が、インデックス項目で表現される行に対して真かどうかを決定します。
リーフインデックス項目では、これはインデックス付条件の試験と等価です。
一方で内部ツリーノードでは、これはツリーノードで表現されるインデックスの副ツリーを走査する必要があるかどうかを決定します。
結果が<literal>true</>ならば、<literal>recheck</>フラグも返されなければなりません。
これは、述語が確実に真なのか一部のみ真なのかを示します。
<literal>recheck</> = <literal>false</>ならば、インデックスは述語条件を正確に試験されたことを示し、<literal>recheck</>= <literal>true</>ならば行が単に一致候補であることを示します。
この場合、システムは自動的に<replaceable>indexable_operator</>を実際の行値に対して評価し、本当に一致するかどうか確認します。
この規則により、<acronym>GiST</acronym>はインデックス構造が非可逆な場合でもある場合でもサポートすることができます。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_consistent(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

<!--
    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */
-->
    /*
     * strategy、keyおよびqueryの関数として戻り値を決定してください。
     *
     * インデックスツリー内のどこで呼びだされているかを知るためGIST_LEAF(entry)を使用してください。
     * それは、例えば = 演算子をサポートする場合重宝です
     *（非リーフノードにおける空でないunion()とリーフノードにおける等価性を検査することができます）。
     */

<!--
    *recheck = true;        /* or false if check is exact */
-->
    *recheck = true;        /* もしくは検査が正確であれば偽 */

    PG_RETURN_BOOL(retval);
}
</programlisting>

<!--
       Here, <varname>key</> is an element in the index and <varname>query</>
       the value being looked up in the index. The <literal>StrategyNumber</>
       parameter indicates which operator of your operator class is being
       applied &mdash; it matches one of the operator numbers in the
       <command>CREATE OPERATOR CLASS</> command.  Depending on what operators
       you have included in the class, the data type of <varname>query</> could
       vary with the operator, but the above skeleton assumes it doesn't.
-->
ここで、<varname>key</>はインデックス要素であり、<varname>query</>はインデックスに対して検索される値です。
<literal>StrategyNumber</>パラメータは、演算子クラスのどの演算子が適用されるかを示します。
これは<command>CREATE OPERATOR CLASS</>コマンドの演算子番号の1つに一致します。
このクラスに含めた演算子が何かに応じて、<varname>query</>のデータ型は変動することがあります。
しかし、上記骨格は変動しないものと考えられます。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>union</></term>
     <listitem>
      <para>
<!--
       This method consolidates information in the tree.  Given a set of
       entries, this function generates a new index entry that represents
       all the given entries.
-->
このメソッドはツリー内の情報を統合します。
項目の集合が与えられると、この関数は与えられた項目すべてを表現するインデックス項目を新しく生成します。
      </para>

      <para>
      <!--
        The <acronym>SQL</> declaration of the function must look like this:
	-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_union(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</programlisting>
      </para>

      <para>
<!--
        As you can see, in this skeleton we're dealing with a data type
        where <literal>union(X, Y, Z) = union(union(X, Y), Z)</>. It's easy
        enough to support data types where this is not the case, by
        implementing the proper union algorithm in this
        <acronym>GiST</> support method.
-->
ご覧になったように、この骨格で<literal>union(X, Y, Z) = union(union(X, Y), Z)</>であるようなデータ型を処理しています。
この<acronym>GiST</>サポートメソッドに適切なunionアルゴリズムを実装することで、このような場合以外のデータ型をサポートすることは非常に容易です。
      </para>

      <para>
<!--
        The <function>union</> implementation function should return a
        pointer to newly <function>palloc()</>ed memory. You can't just
        return whatever the input is.
-->
<function>union</>の実装関数は新たに<function>palloc()</>されたメモリへのポインタを返さなければなりません。
単に入力されたものを返すことはできません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>compress</></term>
     <listitem>
      <para>
<!--
       Converts the data item into a format suitable for physical storage in
       an index page.
-->
データ項目をインデックスページ内の物理的な格納に適した形式に変換します。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_compress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
<!--
        /* replace entry-&gt;key with a compressed version */
-->
        /* 圧縮バージョンで entry-&gt;key を差し替え */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

<!--
        /* fill *compressed_data from entry-&gt;key ... */
-->
        /* entry-&gt;key ... から *compressed_data を補填 */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
<!--
        /* typically we needn't do anything with non-leaf entries */
-->
        /* 通常非リーフ項目に対して行うことはない */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>

      <para>
<!--
       You have to adapt <replaceable>compressed_data_type</> to the specific
       type you're converting to in order to compress your leaf nodes, of
       course.
-->
当然ながら<replaceable>compressed_data_type</>を、リーフノードを圧縮するために変換する特定の型に適合させなければなりません。
      </para>

      <para>
<!--
        Depending on your needs, you could also need to care about
        compressing <literal>NULL</> values in there, storing for example
        <literal>(Datum) 0</> like <literal>gist_circle_compress</> does.
-->
また必要に応じて、ここで<literal>NULL</>値の圧縮に関して注意をしなければなりません。
例えば<literal>gist_circle_compress</>などでは<literal>(Datum) 0</>を格納します。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decompress</></term>
     <listitem>
      <para>
<!--
       The reverse of the <function>compress</function> method.  Converts the
       index representation of the data item into a format that can be
       manipulated by the database.
-->
<function>compress</function>メソッドの逆です。
データ項目のインデックス表現から、データベースで扱うことができる書式に変換します。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_decompress(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</programlisting>

<!--
        The above skeleton is suitable for the case where no decompression
        is needed.
-->
上記骨格は、伸長を必要としない場合に適したものです。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>penalty</></term>
     <listitem>
      <para>
<!--
       Returns a value indicating the <quote>cost</quote> of inserting the new
       entry into a particular branch of the tree.  Items will be inserted
       down the path of least <function>penalty</function> in the tree.
       Values returned by <function>penalty</function> should be non-negative.
       If a negative value is returned, it will be treated as zero.
-->
新しい項目をツリーの特定の分岐点に挿入するための<quote>コスト</quote>を示す値を返します。
項目は、ツリー内で<function>penalty</function>が最小の経路に挿入されます。
<function>penalty</function>から返される値は非負でなければなりません。
負の値が返された場合、ゼロとして扱われます。
      </para>

      <para>
      <!--
        The <acronym>SQL</> declaration of the function must look like this:
	-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_penalty(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</programlisting>
      </para>

      <para>
<!--
        The <function>penalty</> function is crucial to good performance of
        the index. It'll get used at insertion time to determine which branch
        to follow when choosing where to add the new entry in the tree. At
        query time, the more balanced the index, the quicker the lookup.
-->
<function>penalty</>関数は優れた性能のインデックスではきわめて重要です。
これは、挿入の段階で新しい項目をツリーに追加する場所を決定する際にどの分岐に従うかを決定するために使用されます。
問い合わせの際、インデックスのバランスが良ければ、検索が速くなります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</></term>
     <listitem>
      <para>
<!--
       When an index page split is necessary, this function decides which
       entries on the page are to stay on the old page, and which are to move
       to the new page.
-->
インデックスページ分割が必要になった時、この関数は、ページ内のどの項目を古いページに残すか、および、どれを新しいページに移動するかを決定します。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_picksplit(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

<!--
    /* Initialize the raw entry vector. */
-->
    /* 項目自体のベクタの初期化 */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

<!--
        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v_spl_left or
         * v_spl_right, and care about the counters.
         */
-->
        /*
         * インデックス項目の格納場所を決定し、それに合わせてunionLとunionRを更新
         * します。v_spl_left もしくは v_spl_right のどちらかに項目を追加します。
         * カウンタに留意してください。
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</programlisting>
      </para>

      <para>
<!--
        Like <function>penalty</>, the <function>picksplit</> function
        is crucial to good performance of the index.  Designing suitable
        <function>penalty</> and <function>picksplit</> implementations
        is where the challenge of implementing well-performing
        <acronym>GiST</> indexes lies.
-->
<function>penalty</>同様、<function>picksplit</>関数も優れた性能のインデックスのためにきわめて重要です。
<function>penalty</>と<function>picksplit</>の実装を適切に設計することが、性能が良い<acronym>GiST</>インデックスの実装を行うことにつながります。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>same</></term>
     <listitem>
      <para>
<!--
       Returns true if two index entries are identical, false otherwise.
-->
２つのインデックス項目が同一の場合に真、さもなくば偽を返します。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
この関数の<acronym>SQL</>宣言は以下のようになります。

<programlisting>
CREATE OR REPLACE FUNCTION my_same(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

<programlisting>
Datum       my_same(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</programlisting>

<!--
        For historical reasons, the <function>same</> function doesn't
        just return a Boolean result; instead it has to store the flag
        at the location indicated by the third argument.
-->
歴史的な理由により、<function>same</>関数は単純に論理値の結果を返しません。
その代わり、３番目の引数で指定された場所にフラグを格納しなければなりません。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>distance</></term>
     <listitem>
      <para>
<!--
       Given an index entry <literal>p</> and a query value <literal>q</>,
       this function determines the index entry's
       <quote>distance</> from the query value.  This function must be
       supplied if the operator class contains any ordering operators.
       A query using the ordering operator will be implemented by returning
       index entries with the smallest <quote>distance</> values first,
       so the results must be consistent with the operator's semantics.
       For a leaf index entry the result just represents the distance to
       the index entry; for an internal tree node, the result must be the
       smallest distance that any child entry could have.
-->
インデックス項目<literal>p</>と問い合わせ値<literal>q</>を与えると、この関数は問い合わせ値からのインデックス項目の<quote>距離</>を決定します。
この関数は、演算子クラスが何らかの順序付け演算子を含む場合には提供しなければなりません。
順序付け演算子を使用する問い合わせは、まず最小の<quote>距離</>を持つインデックス項目を返すことで実装されます。
このためこの結果は演算子の意味と一貫性を持たなければなりません。
リーフインデックスノード項目では、結果は単にインデックス項目との距離を表します。
内部ツリーノードでは、結果はすべての子項目が持つ中から最も最小の距離でなければなりません。
      </para>

      <para>
<!--
        The <acronym>SQL</> declaration of the function must look like this:
-->
この関数の<acronym>SQL</>宣言は以下のようにならなければなりません。

<programlisting>
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

<!--
        And the matching code in the C module could then follow this skeleton:
-->
Cモジュールにおける対応するコードは次の骨格に従うことになります。

<programlisting>
Datum       my_distance(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * determine return value as a function of strategy, key and query.
     */

    PG_RETURN_FLOAT8(retval);
}
</programlisting>

<!--
       The arguments to the <function>distance</> function are identical to
       the arguments of the <function>consistent</> function, except that no
       recheck flag is used.  The distance to a leaf index entry must always
       be determined exactly, since there is no way to re-order the tuples
       once they are returned.  Some approximation is allowed when determining
       the distance to an internal tree node, so long as the result is never
       greater than any child's actual distance.  Thus, for example, distance
       to a bounding box is usually sufficient in geometric applications.  The
       result value can be any finite <type>float8</> value.  (Infinity and
       minus infinity are used internally to handle cases such as nulls, so it
       is not recommended that <function>distance</> functions return these
       values.)
-->
<function>distance</>関数の引数は、recheckフラグが使用されない点を除いて、<function>consistent</>関数の引数と同一です。
タプルが返された後タプルを再度順序付けする手段がありませんので、リーフインデックス項目への距離は常に正確に決定される必要があります。
内部ツリーノードへの距離の決定に関しては、その結果がすべての子の実際の距離よりも大きくならない限り、多少の概算は許されます。
したがって、例えば、幾何学に関するアプリケーションでは、通常境界矩形への距離で十分です。
結果値は何らかの有限の<type>float8</>になります。
（無限大やマイナス無限大はNULLなどの場合を扱うために内部的に使用されます。
このため<function>distance</>関数がこれらの値を返すことは勧められません。）
      </para>

     </listitem>
    </varlistentry>

  </variablelist>

  <para>
<!--
   All the GiST support methods are normally called in short-lived memory
   contexts; that is, <varname>CurrentMemoryContext</> will get reset after
   each tuple is processed.  It is therefore not very important to worry about
   pfree'ing everything you palloc.  However, in some cases it's useful for a
   support method to cache data across repeated calls.  To do that, allocate
   the longer-lived data in <literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</>, and
   keep a pointer to it in <literal>fcinfo-&gt;flinfo-&gt;fn_extra</>.  Such
   data will survive for the life of the index operation (e.g., a single GiST
   index scan, index build, or index tuple insertion).  Be careful to pfree
   the previous value when replacing a <literal>fn_extra</> value, or the leak
   will accumulate for the duration of the operation.
-->
すべてのGiSTサポートメソッドは通常短期間有効なメモリコンテキストで呼び出されます。
つまり<varname>CurrentMemoryContext</>は各タプルが処理された後にリセットされます。
そのためpallocしたすべてをpfreeすることに注意することはあまり重要ではありません。
しかし、サポートメソッドで、繰り返される呼び出しを跨がってデータをキャッシュすることが有用な場合があります。
このためには、<literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</>の中で超期間有効なデータを割り当て、そこへのポインタを<literal>fcinfo-&gt;flinfo-&gt;fn_extra</>の中に保持してください。
こうしたデータはインデックス操作（例えば１つのGiSTインデックススキャン、インデックス構築、インデックスタプルの挿入）の間有効です。
<literal>fn_extra</>値を置き換える時に以前の値をpfreeすることに注意してください。
さもないと操作の間リークが蓄積されます。
  </para>

</sect1>

<sect1 id="gist-implementation">
<!--
 <title>Implementation</title>
-->
 <title>実装</title>

 <sect2 id="gist-buffering-build">
<!--
  <title>GiST buffering build</title>
-->
  <title>バッファ付きGiST構築</title>
  <para>
<!--
   Building large GiST indexes by simply inserting all the tuples tends to be
   slow, because if the index tuples are scattered across the index and the
   index is large enough to not fit in cache, the insertions need to perform
   a lot of random I/O.  Beginning in version 9.2, PostgreSQL supports a more
   efficient method to build GiST indexes based on buffering, which can
   dramatically reduce the number of random I/Os needed for non-ordered data
   sets. For well-ordered data sets the benefit is smaller or non-existent,
   because only a small number of pages receive new tuples at a time, and
   those pages fit in cache even if the index as whole does not.
-->
すべてのタプルを単純に挿入することによって大規模なGiSTインデックスを構築することは、インデックスタプルがインデックス全体に分散し、インデックスがキャッシュに収まらない程大規模である場合、挿入の際に大量のランダムI/Oを行わなければなりませんので、低速になりがちです。
バージョン9.2からPostgreSQLはバッファ処理に基づいてGiSTインデックスを構築するより効率的な方法をサポートします。
これは、順序付けされていないデータ群に対して必要なランダムI/O数を劇的に減らします。
十分に順序付けされたデータ群では、一度にわずかなページ数のみが新しいタプルを受け取り、そのためインデックス全体がキャッシュに収まらなくてもこれらのページがキャッシュ内に収まりますので、利点はより小さく、または利点がなくなります。
  </para>

  <para>
<!--
   However, buffering index build needs to call the <function>penalty</>
   function more often, which consumes some extra CPU resources. Also, the
   buffers used in the buffering build need temporary disk space, up to
   the size of the resulting index. Buffering can also influence the quality
   of the resulting index, in both positive and negative directions. That
   influence depends on various factors, like the distribution of the input
   data and the operator class implementation.
-->
しかしバッファ付きインデックス構築は、CPUリソースを多少多く消費する<function>penalty</>関数をより多く呼び出さなければなりません。
またバッファ付き構築で使用されるバッファは、最大作成されるインデックスと同じサイズまで、一時的にディスク容量を必要とします。
バッファ処理は作成されるインデックスの品質にも、良くも悪くも、影響を与えます。
この影響は、入力データの分布や演算子クラスの実装等、様々な要因に依存します。
  </para>

  <para>
<!--
   By default, a GiST index build switches to the buffering method when the
   index size reaches <xref linkend="guc-effective-cache-size">. It can
   be manually turned on or off by the <literal>BUFFERING</literal> parameter
   to the CREATE INDEX command. The default behavior is good for most cases,
   but turning buffering off might speed up the build somewhat if the input
   data is ordered.
-->
デフォルトでは、インデックスのサイズが<xref linkend="guc-effective-cache-size">に達した時にGiSTインデックス構築はバッファ処理方式に切り替わります。
CREATE INDEXコマンドの<literal>BUFFERING</literal>パラメータによって、手作業で有効または無効にすることができます。
デフォルトの動作は大抵の場合良好です。
しかし、入力データが順序付けされている場合、バッファ処理を無効にすることで構築が多少高速になります。
  </para>

 </sect2>
</sect1>

<sect1 id="gist-examples">
<!--
 <title>Examples</title>
-->
 <title>例</title>

 <para>
<!--
  The <productname>PostgreSQL</productname> source distribution includes
  several examples of index methods implemented using
  <acronym>GiST</acronym>.  The core system currently provides text search
  support (indexing for <type>tsvector</> and <type>tsquery</>) as well as
  R-Tree equivalent functionality for some of the built-in geometric data types
  (see <filename>src/backend/access/gist/gistproc.c</>).  The following
  <filename>contrib</> modules also contain <acronym>GiST</acronym>
  operator classes:
-->
<productname>PostgreSQL</productname>のソース配布物には<acronym>GiST</acronym>を使用したインデックスメソッドの実装のいくつかの事例が含まれています。
コアシステムは現在全文検索サポート（<type>tsvector</>と<type>tsquery</>のインデックス付け）や組み込みの幾何データ型の一部に対するR-Treeと等価な機能を提供します
（<filename>src/backend/access/gist/gistproc.c</>を参照してください）。
以下の<filename>contrib</>モジュールも同時に<acronym>GiST</acronym>演算子クラスを含みます。

 <variablelist>
  <varlistentry>
   <term><filename>btree_gist</></term>
   <listitem>
<!--
    <para>B-tree equivalent functionality for several data types</para>
-->
    <para>いくつかのデータ型に対するB-tree等価機能</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>cube</></term>
   <listitem>
<!--
    <para>Indexing for multidimensional cubes</para>
-->
    <para>多次元の立方体用のインデックス</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</></term>
   <listitem>
<!--
    <para>Module for storing (key, value) pairs</para>
-->
    <para>（キー、値）の組み合わせを格納するモジュール</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</></term>
   <listitem>
<!--
    <para>RD-Tree for one-dimensional array of int4 values</para>
-->
    <para>int4値の1次元配列用のRD-Tree</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>ltree</></term>
   <listitem>
<!--
    <para>Indexing for tree-like structures</para>
-->
    <para>疑似ツリー構造用のインデックス</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</></term>
   <listitem>
<!--
    <para>Text similarity using trigram matching</para>
-->
    <para>トリグラム一致を使用したテキストの類似性</para>
   </listitem>

  </varlistentry>

  <varlistentry>
   <term><filename>seg</></term>
   <listitem>
<!--
    <para>Indexing for <quote>float ranges</quote></para>
-->
    <para><quote>浮動小数点範囲</quote>のインデックス</para>
   </listitem>
  </varlistentry>
 </variablelist>
 </para>

</sect1>

</chapter>
