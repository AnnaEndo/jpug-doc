<!-- doc/src/sgml/xaggr.sgml -->

 <sect1 id="xaggr">
<!--
  <title>User-defined Aggregates</title>
-->
  <title>ユーザ定義の集約</title>

  <indexterm zone="xaggr">
<!--
   <primary>aggregate function</primary>
   <secondary>user-defined</secondary>
-->
   <primary>集約関数</primary>
   <secondary>ユーザ定義</secondary>
  </indexterm>

  <para>
<!--
   Aggregate functions  in <productname>PostgreSQL</productname>
   are expressed in terms of <firstterm>state values</firstterm>
   and <firstterm>state transition functions</firstterm>.
   That is, an aggregate operates using a state value that is updated
   as each successive input row is processed.
   To define a new aggregate
   function, one selects a data type for the state value,
   an initial value for the state, and a state transition
   function.  The state transition function is just an
   ordinary function that could also be used outside the
   context of the aggregate.  A <firstterm>final function</firstterm>
   can also be specified, in case the desired result of the aggregate
   is different from the data that needs to be kept in the running
   state value.
-->
<productname>PostgreSQL</productname>における集約関数は、<firstterm>状態値</firstterm>と<firstterm>状態遷移関数</firstterm>で表現されています。
つまり、1つの集約は入力行が処理される度に変更される状態値を使用して演算されます。
新しい集約関数を定義するためには、状態値のデータ型、状態の初期値、そして状態遷移関数を選択します。
状態遷移関数はただの普通の関数で、集約以外の文脈でも使うことができます。
求められる集約の結果が遷移する状態値の中に保持しなければならないデータと違う場合は、<firstterm>最終関数</firstterm>も指定することができます。
  </para>

  <para>
<!--
   Thus, in addition to the argument and result data types seen by a user
   of the aggregate, there is an internal state-value data type that
   might be different from both the argument and result types.
-->
したがって、集約のユーザに見える引数と結果のデータ型に加え、引数と結果の型のどちらとも違う可能性がある内部状態値のデータ型があります。
  </para>

  <para>
<!--
   If we define an aggregate that does not use a final function,
   we have an aggregate that computes a running function of
   the column values from each row.  <function>sum</>  is  an
   example  of  this  kind  of aggregate.  <function>sum</> starts at
   zero and always adds the current  row's  value  to
   its  running  total.  For example, if we want to make a <function>sum</>
   aggregate to work on a data type for complex numbers,
   we only need the addition function for that data type.
   The aggregate definition would be:
-->
もし最終関数を使わない集約を定義したとすると、それぞれの行の列値で変動する関数で計算された結果の集約ができます。
<function>sum</>はそのような集約の一例です。
<function>sum</>は0から始まり、常に現在の行の値をその時点までの総和に追加します。
例えば、もし<function>sum</>集約を複素数のデータ型で動作するようにしたければ、そのデータ型の加算関数だけが必要になります。
集約定義は以下のようになります。

<screen>
CREATE AGGREGATE sum (complex)
(
    sfunc = complex_add,
    stype = complex,
    initcond = '(0,0)'
);

SELECT sum(a) FROM test_complex;

   sum
-----------
 (34,53.9)
</screen>

<!--
   (Notice that we are relying on function overloading: there is more than
    one aggregate named <function>sum</>, but
   <productname>PostgreSQL</productname> can figure out which kind
   of sum applies to a column of type <type>complex</type>.)
-->
（関数のオーバーライド機能に依存していることに注意してください。
<function>sum</>という名前の集約関数は複数存在しますが、<productname>PostgreSQL</productname>は列の型<type>complex</type>に適用できるsum関数を見つけ出すことができます。）
  </para>

  <para>
<!--
   The above definition of <function>sum</function> will return zero (the initial
   state condition) if there are no nonnull input values.
   Perhaps we want to return null in that case instead &mdash; the SQL standard
   expects <function>sum</function> to behave that way.  We can do this simply by
   omitting the <literal>initcond</literal> phrase, so that the initial state
   condition is null.  Ordinarily this would mean that the <literal>sfunc</literal>
   would need to check for a null state-condition input.  But for
   <function>sum</function> and some other simple aggregates like
   <function>max</> and <function>min</>,
   it is sufficient to insert the first nonnull input value into
   the state variable and then start applying the transition function
   at the second nonnull input value.  <productname>PostgreSQL</productname>
   will do that automatically if the initial condition is null and
   the transition function is marked <quote>strict</> (i.e., not to be called
   for null inputs).
-->
上記の<function>sum</function>の定義は、もし非NULLの入力値がなければ0（初期状態）を返します。
その場合本来は代わりにNULLを返したいのではないかと思いますし、標準SQLでは<function>sum</function>がそのように動作することを期待しています。
そうするためには単に<literal>initcond</literal>句を省略すれば、初期状態がNULLになります。
通常はそうすると、<literal>sfunc</literal>がNULL状態の入力をチェックしなければいけないということを意味します。
しかし<function>sum</function>や、その他<function>max</function>、<function>min</function>のような単純な集約にとっては、最初の非NULL入力値を状態変数に挿入し、2番目の非NULL入力値で状態遷移関数を当てはめ始めれば十分です。
<productname>PostgreSQL</productname>は、もし初期状態がNULLで状態遷移関数が<quote>厳密（strict）</>と設定されている場合、自動的にそれを実行します（つまりNULL入力では呼び出されないようになります）。
  </para>

  <para>
<!--
   Another bit of default behavior for a <quote>strict</> transition function
   is that the previous state value is retained unchanged whenever a
   null input value is encountered.  Thus, null values are ignored.  If you
   need some other behavior for null inputs, do not declare your
   transition function as strict; instead code it to test for null inputs and
   do whatever is needed.
-->
もう1つの<quote>厳密</>な状態遷移関数のデフォルト動作としては、NULL入力値が現れると前の状態値が変わらずに維持されるということがあります。
したがって、NULL値は無視されます。
もしNULL入力に対し他の動作が必要な場合は、状態遷移関数を厳密として定義しないで、NULL入力の検査を行うようにコーディングし、必要なことをすればよいのです。
  </para>

  <para>
<!--
   <function>avg</> (average) is a more complex example of an aggregate.
   It requires
   two pieces of running state: the sum of the inputs and the count
   of the number of inputs.  The final result is obtained by dividing
   these quantities.  Average is typically implemented by using an
   array as the state value.  For example,
   the built-in implementation of <function>avg(float8)</function>
   looks like:
-->
<function>avg</>（平均値計算）はもっと複雑な集約の一例です。
それには2つの変動する状態が必要になります。入力の合計と入力数のカウントです。
最終的な結果はこれらの値を割算することによって得られます。
平均値計算は典型的に配列を状態遷移値として使って実装されます。
例えば、<function>avg(float8)</function>の組み込みの実装は以下のようになっています。

<programlisting>
CREATE AGGREGATE avg (float8)
(
    sfunc = float8_accum,
    stype = float8[],
    finalfunc = float8_avg,
    initcond = '{0,0,0}'
);
</programlisting>

<!--
   (<function>float8_accum</> requires a three-element array, not just
   two elements, because it accumulates the sum of squares as well as
   the sum and count of the inputs.  This is so that it can be used for
   some other aggregates besides <function>avg</>.)
-->
（<function>float8_accum</>は、入力の総和と個数だけではなく二乗和も蓄積しますので、２要素ではなく、３要素の配列を必要とします。
<function>avg</>以外の何らかの集約でも使用できるようにするためです。）
  </para>

  <para>
<!--
   Aggregate functions can use polymorphic
   state transition functions or final functions, so that the same functions
   can be used to implement multiple aggregates.
   See <xref linkend="extend-types-polymorphic">
   for an explanation of polymorphic functions.
   Going a step further, the aggregate function itself can be specified
   with polymorphic input type(s) and state type, allowing a single
   aggregate definition to serve for multiple input data types.
   Here is an example of a polymorphic aggregate:
-->
集約関数は多様状態遷移関数や多様最終関数を使用することができます。
これにより、同じ関数を使用して複数の集約を実装することができます。
<xref linkend="extend-types-polymorphic">に多様関数の説明があります。
もう少し細かく言うと、集約関数自身は、単一の集約定義で複数の入力データ型を扱うことができるように、多様入力型と多様状態型を指定することができるということです。
以下に多様集約の例を示します。

<programlisting>
CREATE AGGREGATE array_accum (anyelement)
(
    sfunc = array_append,
    stype = anyarray,
    initcond = '{}'
);
</programlisting>

<!--
   Here, the actual state type for any aggregate call is the array type
   having the actual input type as elements.  The behavior of the aggregate
   is to concatenate all the inputs into an array of that type.
   (Note: the built-in aggregate <function>array_agg</> provides similar
   functionality, with better performance than this definition would have.)
-->
ここで、集約を行う呼び出し用の実際の状態型は、その実際の入力型がその要素となる、配列型です。
集約の動作はその型の配列に全ての入力を連結することです。
（組み込みの集約関数<function>array_agg</>は、この定義での動作よりもより良い性能で、類似の機能を提供します。）
  </para>

  <para>
<!--
   Here's the output using two different actual data types as arguments:
-->
以下に異なる2つの実データ型を引数として使用した出力例を示します。

<programlisting>
SELECT attrelid::regclass, array_accum(attname)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |              array_accum              
---------------+---------------------------------------
 pg_tablespace | {spcname,spcowner,spcacl,spcoptions}
(1 row)

SELECT attrelid::regclass, array_accum(atttypid::regtype)
    FROM pg_attribute
    WHERE attnum &gt; 0 AND attrelid = 'pg_tablespace'::regclass
    GROUP BY attrelid;

   attrelid    |        array_accum        
---------------+---------------------------
 pg_tablespace | {name,oid,aclitem[],text[]}
(1 row)
</programlisting>
  </para>

  <para>
<!--
   A function written in C can detect that it is being called as an
   aggregate transition or final function by calling
   <function>AggCheckCallContext</>, for example:
-->
C言語で作成された関数は、例えば以下のように<function>AggCheckCallContext</>を呼び出して、集約の遷移関数または最終関数が呼び出されたかを検出することができます。
<programlisting>
if (AggCheckCallContext(fcinfo, NULL))
</programlisting>
<!--
   One reason for checking this is that when it is true for a transition
   function, the first input
   must be a temporary transition value and can therefore safely be modified
   in-place rather than allocating a new copy.
   See <literal>int8inc()</> for an example.
   (This is the <emphasis>only</>
   case where it is safe for a function to modify a pass-by-reference input.
   In particular, aggregate final functions should not modify their inputs in
   any case, because in some cases they will be re-executed on the same
   final transition value.)
-->
この検査を行う理由の１つとして、遷移関数に対してこれが真の場合、先頭の入力は一時的な遷移中の値であるはずであり、新規に割り当ててコピーを持つことなくそのまま変更しても安全であることが分かることがあります。
例として<literal>int8inc()</>を参照してください。
（これは関数内で参照渡しの入力を安全に変更できる<emphasis>唯一の</>場合です。
特に集約最終関数はいかなる場合でもそれらの入力を変更してはなりません。
と言うのは、時として、同じ最終遷移値上で再実行されることがあるからです。）
  </para>

  <para>
<!--
   For further details see the
   <xref linkend="sql-createaggregate">
   command.
-->
さらに詳しい情報は、<xref linkend="sql-createaggregate">コマンドを参照してください。
  </para>
 </sect1>
