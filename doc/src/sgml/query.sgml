<!-- doc/src/sgml/query.sgml -->

 <chapter id="tutorial-sql">
<!--
  <title>The <acronym>SQL</acronym> Language</title>
-->
  <title><acronym>SQL</acronym>言語</title>

  <sect1 id="tutorial-sql-intro">
<!--
   <title>Introduction</title>
-->
   <title>序文</title>

   <para>
<!--
    This chapter provides an overview of how to use
    <acronym>SQL</acronym> to perform simple operations.  This
    tutorial is only intended to give you an introduction and is in no
    way a complete tutorial on <acronym>SQL</acronym>.  Numerous books
    have been written on <acronym>SQL</acronym>, including <xref
    linkend="MELT93"> and <xref linkend="DATE97">.
    You should be aware that some <productname>PostgreSQL</productname>
    language features are extensions to the standard.
-->
本章では、<acronym>SQL</acronym>を使用した簡単な操作方法について、その概要を説明します。
このチュートリアルは単なる入門用であり、<acronym>SQL</acronym>についての完全な教科書ではありません。
<xref linkend="MELT93">や<xref linkend="DATE97">など、<acronym>SQL</acronym>を説明した書籍は多くあります。
<productname>PostgreSQL</productname>言語が持つ機能の中には標準を拡張したものがあることには注意してください。
   </para>

   <para>
<!--
    In the examples that follow, we assume that you have created a
    database named <literal>mydb</literal>, as described in the previous
    chapter, and have been able to start <application>psql</application>.
-->
以下で示す例では、前章で説明した<literal>mydb</literal>という名前のデータベースを作成し、<application>psql</application>を起動できるようになっていることを前提としています。
   </para>

   <para>
<!--
    Examples in this manual can also be found in the
    <productname>PostgreSQL</productname> source distribution
    in the directory <filename>src/tutorial/</filename>.  (Binary
    distributions of <productname>PostgreSQL</productname> might not
    compile these files.)  To use those
    files, first change to that directory and run <application>make</>:
-->
このマニュアルで示す例は、<productname>PostgreSQL</productname>ソース配布物に含まれており、<filename>src/tutorial/</filename>以下に展開されます。
（<productname>PostgreSQL</productname>のバイナリ配布物ではこのファイルはコンパイルされていないかも知れません。）
このファイルを使用するためには、以下に示すように、まずこのディレクトリに移動し、<application>make</>を実行してください。

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/tutorial</userinput>
<prompt>$</prompt> <userinput>make</userinput>
</screen>

<!--
    This creates the scripts and compiles the C files containing user-defined
    functions and types.  Then, to start the tutorial, do the following:
-->
これによりスクリプトが作成され、そして、ユーザ定義の関数と型を含むCのファイルがコンパイルされます
その後、以下を行うことで、チュートリアルを始めることができます。

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</userinput>
<prompt>$</prompt> <userinput>psql -s mydb</userinput>
<computeroutput>
...
</computeroutput>

<prompt>mydb=&gt;</prompt> <userinput>\i basics.sql</userinput>
</screen>

<!--
    The <literal>\i</literal> command reads in commands from the
    specified file. <command>psql</command>'s <literal>-s</> option puts you in
    single step mode which pauses before sending each statement to the
    server.  The commands used in this section are in the file
    <filename>basics.sql</filename>.
-->
<literal>\i</literal>は、指定したファイルからコマンドを読み込みます。
<command>psql</command>の<literal>-s</>オプションによって、それぞれの文をサーバに送る前に一時停止する、シングルステップモードとなります。
本節で使用するコマンドは<filename>basics.source</filename>ファイル内にあります。
   </para>
  </sect1>


  <sect1 id="tutorial-concepts">
<!--
   <title>Concepts</title>
-->
   <title>概念</title>

   <para>
<!--
    <indexterm><primary>relational database</primary></indexterm>
    <indexterm><primary>hierarchical database</primary></indexterm>
    <indexterm><primary>object-oriented database</primary></indexterm>
    <indexterm><primary>relation</primary></indexterm>
    <indexterm><primary>table</primary></indexterm>
-->
    <indexterm><primary>リレーショナルデータベース</primary></indexterm>
    <indexterm><primary>階層型データベース</primary></indexterm>
    <indexterm><primary>オブジェクト指向データベース</primary></indexterm>
    <indexterm><primary>リレーション</primary></indexterm>
    <indexterm><primary>テーブル</primary></indexterm>

<!--
    <productname>PostgreSQL</productname> is a <firstterm>relational
    database management system</firstterm> (<acronym>RDBMS</acronym>).
    That means it is a system for managing data stored in
    <firstterm>relations</firstterm>.  Relation is essentially a
    mathematical term for <firstterm>table</firstterm>.  The notion of
    storing data in tables is so commonplace today that it might
    seem inherently obvious, but there are a number of other ways of
    organizing databases.  Files and directories on Unix-like
    operating systems form an example of a hierarchical database.  A
    more modern development is the object-oriented database.
-->
<productname>PostgreSQL</productname>は<firstterm>リレーショナルデータベースマネージメントシステム</firstterm>（<acronym>RDBMS</acronym>）です。
これは<firstterm>リレーション</firstterm>の中に格納されたデータを管理するシステムであることを意味しています。
リレーションは基本的には<firstterm>テーブル</firstterm>を表す数学用語です。
テーブルにデータを格納することは今日では平凡なことですので、わかりきったものだと思われるかもしれませんが、データベースを構成する方法には他にも多くの方式があります。
Unix互換のオペレーティングシステムのファイルとディレクトリは、階層型データベースの一種と言えます。
より近代的な成果はオブジェクト指向データベースです。
   </para>

   <para>
<!--
    <indexterm><primary>row</primary></indexterm>
    <indexterm><primary>column</primary></indexterm>
-->
    <indexterm><primary>行</primary></indexterm>
    <indexterm><primary>列</primary></indexterm>

<!--
    Each table is a named collection of <firstterm>rows</firstterm>.
    Each row of a given table has the same set of named
    <firstterm>columns</firstterm>,
    and each column is of a specific data type.  Whereas columns have
    a fixed order in each row, it is important to remember that SQL
    does not guarantee the order of the rows within the table in any
    way (although they can be explicitly sorted for display).
-->
各テーブルは、<firstterm>行</firstterm>の集合に名前を付けたものです。
あるテーブルの各行は、名前を付けた<firstterm>列</firstterm>の集合ということができます。
各列は特定のデータ型を持ちます。
列は行において固定の順番を持ちますが、SQLはテーブルにある行の順番をまったく保証しないことを覚えておくことは重要です
（しかし、表示用に明示的にソートさせることは可能です）。
   </para>

   <para>
<!--
    <indexterm><primary>database cluster</primary></indexterm>
    <indexterm><primary>cluster</primary><secondary>of databases</secondary><see>database cluster</see></indexterm>
-->
    <indexterm><primary>データベースクラスタ</primary></indexterm>
    <indexterm><primary>クラスタ</primary><secondary>データベースの</secondary><see>データベースクラスタ</see></indexterm>

<!--
    Tables are grouped into databases, and a collection of databases
    managed by a single <productname>PostgreSQL</productname> server
    instance constitutes a database <firstterm>cluster</firstterm>.
-->
テーブルはデータベースとしてまとめられ、1つの<productname>PostgreSQL</productname>サーバインスタンスで管理されるデータベースの集合はデータベース<firstterm>クラスタ</firstterm>を構成します。
   </para>
  </sect1>


  <sect1 id="tutorial-table">
<!--
   <title>Creating a New Table</title>
-->
   <title>新しいテーブルの作成</title>

   <indexterm zone="tutorial-table">
    <primary>CREATE TABLE</primary>
   </indexterm>

   <para>
<!--
    You  can  create  a  new  table by specifying the table
    name, along with all column names and their types:
-->
テーブル名と、テーブルの全ての列の名前と型を指定することで、新しいテーブルを作成することができます。

<programlisting>
CREATE TABLE weather (
    city            varchar(80),
<!--
    temp_lo         int,           &#045;- low temperature
    temp_hi         int,           &#045;- high temperature
    prcp            real,          &#045;- precipitation
-->
    temp_lo         int,           -- 最低気温
    temp_hi         int,           -- 最高気温
    prcp            real,          -- 降水量
    date            date
);
</programlisting>

<!--
    You can enter this into <command>psql</command> with the line
    breaks.  <command>psql</command> will recognize that the command
    is not terminated until the semicolon.
-->
上のコマンドを複数の行に分けて<command>psql</command>に入力することができます。
<command>psql</command>は、セミコロンで終わるまでそのコマンドは継続するものと認識します。
   </para>

   <para>
<!--
    White space (i.e., spaces, tabs, and newlines) can be used freely
    in SQL commands.  That means you can type the command aligned
    differently than above, or even all on one line.  Two dashes
    (<quote><literal>&#045;-</literal></quote>) introduce comments.
    Whatever follows them is ignored up to the end of the line.  SQL
    is case insensitive about key words and identifiers, except
    when identifiers are double-quoted to preserve the case (not done
    above).
-->
SQLコマンドでは空白文字（つまり空白、タブ、改行）を自由に使用できます。
つまり、上で示したコマンドとは異なる形で入力できることを意味します。
全てを1行で入力することさえできます。
連続した2つのハイフン（<quote><literal>--</literal></quote>）はコメントの始まりです。
その後に入力したものは、行末まで無視されます。
SQLはキーワードと識別子に対して大文字小文字を区別しません。
ただし、（上では行っていませんが）識別子が二重引用符で括られていた場合は大文字小文字を区別します。
   </para>

   <para>
<!--
    <type>varchar(80)</type> specifies a data type that can store
    arbitrary character strings up to 80 characters in length.
    <type>int</type> is the normal integer type.  <type>real</type> is
    a type for storing single precision floating-point numbers.
    <type>date</type> should be self-explanatory.  (Yes, the column of
    type <type>date</type> is also named <structfield>date</structfield>.
    This might be convenient or confusing &mdash; you choose.)
-->
<type>varchar(80)</type>は、80文字までの任意の文字列を格納できるデータ型を指定しています。
<type>int</type>は一般的な整数用の型です。
<type>real</type>は単精度浮動小数点数値を格納する型です。
<type>date</type>（日付）はその名前からわかるでしょう
（わかると思いますが、<type>date</type>型の列は<structfield>date</structfield>と名付けられています。
これはわかりやすいかもしれませんし、逆に混乱を招くかもしれません。
これは好みによります）。
   </para>

   <para>
<!--
    <productname>PostgreSQL</productname> supports the standard
    <acronym>SQL</acronym> types <type>int</type>,
    <type>smallint</type>, <type>real</type>, <type>double
    precision</type>, <type>char(<replaceable>N</>)</type>,
    <type>varchar(<replaceable>N</>)</type>, <type>date</type>,
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type>, as well as other types of general utility
    and a rich set of geometric types.
    <productname>PostgreSQL</productname> can be customized with an
    arbitrary number of user-defined data types.  Consequently, type
    names are not key words in the syntax, except where required to
    support special cases in the <acronym>SQL</acronym> standard.
-->
<productname>PostgreSQL</productname>は標準<acronym>SQL</acronym>のデータ型、<type>int</type>、<type>smallint</type>、<type>real</type>、<type>double precision</type>、<type>char(<replaceable>N</>)</type>、<type>varchar(<replaceable>N</>)</type>、<type>date</type>、<type>time</type>、<type>timestamp</type>や<type>interval</type>をサポートします。
また、一般的なユーティリティ用の型や高度な幾何データ型もサポートします。
任意の数のユーザ定義のデータ型を使用して、<productname>PostgreSQL</productname>をカスタマイズすることができます。
したがって、標準<acronym>SQL</acronym>における特殊な場合をサポートするために必要な場所を除き、型名は構文内でキーワードではありません。
   </para>

   <para>
<!--
    The second example will store cities and their associated
    geographical location:
-->
以下に示す2番目の例では、都市とその地理的な位置情報を格納します。
<programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
<!--
    The <type>point</type> type is an example of a
    <productname>PostgreSQL</productname>-specific data type.
-->
<type>point</type>型は、<productname>PostgreSQL</productname>独自のデータ型の一例です。
   </para>

   <para>
    <indexterm>
     <primary>DROP TABLE</primary>
    </indexterm>

<!--
    Finally, it should be mentioned that if you don't need a table any
    longer or want to recreate it differently you can remove it using
    the following command:
-->
最後に、テーブルが不要になった場合や別のものに作り直したい場合、以下のコマンドを使用して削除できることを示します。
<synopsis>
DROP TABLE <replaceable>tablename</replaceable>;
</synopsis>
   </para>
  </sect1>


  <sect1 id="tutorial-populate">
<!--
   <title>Populating a Table With Rows</title>
-->
   <title>テーブルに行を挿入</title>

   <indexterm zone="tutorial-populate">
    <primary>INSERT</primary>
   </indexterm>

   <para>
<!--
    The <command>INSERT</command> statement is used to populate a table  with
    rows:
-->
以下のように、<command>INSERT</command>文を使用して、テーブルに行を挿入します。

<programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>

<!--
    Note that all data types use rather obvious input formats.
    Constants that are not simple numeric values usually must be
    surrounded by single quotes (<literal>'</>), as in the example.
    The
    <type>date</type> type is actually quite flexible in what it
    accepts, but for this tutorial we will stick to the unambiguous
    format shown here.
-->
全てのデータ型でどちらかといえばわかりやすい入力書式を使用していることに注意してください。
通常、単純な数値以外の定数は、この例のように、単一引用符（<literal>'</>）で括らなければなりません。
<type>date</type>型で受け付けられるものは実際はかなり柔軟です。
しかし、このチュートリアルの段階では、曖昧さがない書式にこだわることにします。
   </para>

   <para>
<!--
    The <type>point</type> type requires a coordinate pair as input,
    as shown here:
-->
<type>point</type>型では、入力として次のような座標の組み合わせが必要です。
<programlisting>
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>

   <para>
<!--
    The syntax used so far requires you to remember the order of the
    columns.  An alternative syntax allows you to list the columns
    explicitly:
-->
ここまでの構文では、列の順番を覚えておく必要がありました。
以下に示す他の構文では、列のリストを明示的に与えることができます。
<programlisting>
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
<!--
    You can list the columns in a different order if you wish or
    even omit some columns, e.g., if the precipitation is unknown:
-->
リスト内の列は好きな順番で指定できます。 
また、一部の列を省略することもできます。 
例えば、降水量がわからない場合は以下のようにすることができます。
<programlisting>
INSERT INTO weather (date, city, temp_hi, temp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
<!--
    Many developers consider explicitly listing the columns better
    style than relying on the order implicitly.
-->
多くの開発者は、暗黙的な順番に依存するよりも、列のリストを明示的に指定する方を好んで使用します。
   </para>

   <para>
<!--
    Please enter all the commands shown above so you have some data to
    work with in the following sections.
-->
次節でもデータを使用しますので、上のコマンドを全て入力してください。
   </para>

   <para>
    <indexterm>
     <primary>COPY</primary>
    </indexterm>

<!--
    You could also have used <command>COPY</command> to load large
    amounts of data from flat-text files.  This is usually faster
    because the <command>COPY</command> command is optimized for this
    application while allowing less flexibility than
    <command>INSERT</command>.  An example would be:
-->
また、<command>COPY</command>を使用して大量のデータを平文テキストファイルからロードすることもできます。
<command>COPY</command>コマンドは<command>INSERT</command>よりも柔軟性はありませんが、この目的に特化していますので、通常、より高速になります。
以下に例を示します。

<programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>

<!--
    where the file name for the source file must be available on the
    machine running the backend process, not the client, since the backend process
    reads the file directly.  You can read more about the
    <command>COPY</command> command in <xref linkend="sql-copy">.
-->
ここで元となるファイルを表すファイル名は、クライアントではなく、バックエンドプロセスを動かしているマシンで利用できるものでなければなりません。
バックエンドプロセスがこのファイルを直接読み込むからです。
<xref linkend="sql-copy">には<command>COPY</command>コマンドについてのより詳しい説明があります。
   </para>
  </sect1>


  <sect1 id="tutorial-select">
<!--
   <title>Querying a Table</title>
-->
   <title>テーブルへの問い合わせ</title>

   <para>
<!--
    <indexterm><primary>query</primary></indexterm>
-->
    <indexterm><primary>問い合わせ</primary></indexterm>
    <indexterm><primary>SELECT</primary></indexterm>

<!--
    To retrieve data from a table, the table is
    <firstterm>queried</firstterm>.  An <acronym>SQL</acronym>
    <command>SELECT</command> statement is used to do this.  The
    statement is divided into a select list (the part that lists the
    columns to be returned), a table list (the part that lists the
    tables from which to retrieve the data), and an optional
    qualification (the part that specifies any restrictions).  For
    example, to retrieve all the rows of table
    <structname>weather</structname>, type:
-->
テーブルからデータを取り出すために、テーブルへ<firstterm>問い合わせ</firstterm>をします。
このために<acronym>SQL</acronym>の<command>SELECT</command>文が使用されます。
この文は選択リスト（返される列のリスト部分）とテーブルリスト（データを取り出すテーブルのリスト部分）、および、省略可能な条件（制限を指定する部分）に分けることができます。
例えば、<structname>weather</structname>の全ての行を取り出すには、以下を入力します。
<programlisting>
SELECT * FROM weather;
</programlisting>
<!--
    Here <literal>*</literal> is a shorthand for <quote>all columns</quote>.
-->
ここで<literal>*</literal>は<quote>全ての列</quote>の省略形です。
     <footnote>
      <para>
<!--
       While <literal>SELECT *</literal> is useful for off-the-cuff
       queries, it is widely considered bad style in production code,
       since adding a column to the table would change the results.
-->
<literal>SELECT *</literal>は即興的な問い合わせで有用ですが、製品レベルのコードでは、テーブルに列を追加することにより結果が異なってしまいますので、通常好まれません。
      </para>
     </footnote>
<!--
    So the same result would be had with:
-->
したがって、以下のようにしても同じ結果になります。
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
</programlisting>

<!--
    The output should be:
-->
出力は、以下のようになります。

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</screen>
   </para>

   <para>
<!--
    You can write expressions, not just simple column references, in the
    select list.  For example, you can do:
-->
選択リストには、単なる列参照だけではなく任意の式を指定することができます。
例えば、以下を行うことができます。
<programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</programlisting>
<!--
    This should give:
-->
この結果は次のようになります。
<screen>
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</screen>
<!--
    Notice how the <literal>AS</literal> clause is used to relabel the
    output column.  (The <literal>AS</literal> clause is optional.)
-->
<literal>AS</literal>句を使用した出力列の再ラベル付けの部分に注意してください
（<literal>AS</literal>句は省略することができます）。
   </para>

   <para>
<!--
    A query can be <quote>qualified</> by adding a <literal>WHERE</>
    clause that specifies which rows are wanted.  The <literal>WHERE</>
    clause contains a Boolean (truth value) expression, and only rows for
    which the Boolean expression is true are returned.  The usual
    Boolean operators (<literal>AND</literal>,
    <literal>OR</literal>, and <literal>NOT</literal>) are allowed in
    the qualification.  For example, the following
    retrieves the weather of San Francisco on rainy days:
-->
必要な行が何かを指定する<literal>WHERE</>句を追加して問い合わせに<quote>条件付け</>することができます。
<literal>WHERE</>句は論理（真値）式を持ち、この論理式が真となる行のみを返します。
よく使われる論理演算子（<literal>AND</literal>、<literal>OR</literal>、<literal>NOT</literal>）を条件付けに使用することができます。
例えば以下は、San Franciscoの雨天時の気象データを取り出します。

<programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
<!--
    Result:
-->
結果は次のようになります。
<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>ORDER BY</primary></indexterm>

<!--
    You can request that the results of a query
    be returned in sorted order:
-->
問い合わせの結果をソートして返すように指定することができます。

<programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</screen>

<!--
    In this example, the sort order isn't fully specified, and so you
    might get the San Francisco rows in either order.  But you'd always
    get the results shown above if you do:
-->
この例では、ソート順は十分に指定されていません。
ですので、San Franciscoの行は順序が異なるかも知れません。
しかし、次のようにすれば常に上記の結果になります。

<programlisting>
SELECT * FROM weather
    ORDER BY city, temp_lo;
</programlisting>
   </para>

   <para>
    <indexterm><primary>DISTINCT</primary></indexterm>
<!--
    <indexterm><primary>duplicate</primary></indexterm>
-->
    <indexterm><primary>重複</primary></indexterm>

<!--
    You can request that duplicate rows be removed from the result of
    a query:
-->
問い合わせの結果から重複行を除くように指定することができます。

<programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>

<screen>
     city
---------------
 Hayward
 San Francisco
(2 rows)
</screen>

<!--
    Here again, the result row ordering might vary.
    You can ensure consistent results by using <literal>DISTINCT</literal> and
    <literal>ORDER BY</literal> together:
-->
繰り返しますが、結果行の順序は変動するかもしれません。
<literal>DISTINCT</literal>と<literal>ORDER BY</literal>を一緒に使用することで確実に一貫した結果を得ることができます。
     <footnote>
      <para>
<!--
       In some database systems, including older versions of
       <productname>PostgreSQL</productname>, the implementation of
       <literal>DISTINCT</literal> automatically orders the rows and
       so <literal>ORDER BY</literal> is unnecessary.  But this is not
       required by the SQL standard, and current
       <productname>PostgreSQL</productname> does not guarantee that
       <literal>DISTINCT</literal> causes the rows to be ordered.
-->
<productname>PostgreSQL</productname>の古めのバージョンを含む一部のデータベースシステムでは、<literal>DISTINCT</literal>の実装に行の自動順序付けが含まれており、<literal>ORDER BY</literal>は不要です。
しかし、これは標準SQLにおける要求ではなく、現在の<productname>PostgreSQL</productname>では<literal>DISTINCT</literal>句が行の順序付けを行うことを保証していません。
      </para>
     </footnote>

<programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
もちろん、<literal>DISTINCT</literal>および<literal>ORDER BY</literal>は単体でも使用することができます。 
   </para>
  </sect1>


  <sect1 id="tutorial-join">
<!--
   <title>Joins Between Tables</title>
-->
   <title>テーブル間を結合</title>

   <indexterm zone="tutorial-join">
<!--
    <primary>join</primary>
-->
    <primary>結合</primary>
   </indexterm>

   <para>
<!--
    Thus far, our queries have only accessed one table at a time.
    Queries can access multiple tables at once, or access the same
    table in such a way that multiple rows of the table are being
    processed at the same time.  A query that accesses multiple rows
    of the same or different tables at one time is called a
    <firstterm>join</firstterm> query.  As an example, say you wish to
    list all the weather records together with the location of the
    associated city.  To do that, we need to compare the <structfield>city</>
    column of each row of the <structname>weather</> table with the
    <structfield>name</> column of all rows in the <structname>cities</>
    table, and select the pairs of rows where these values match.
-->
ここまでの問い合わせは、一度に1つのテーブルにのみアクセスするものでした。
問い合わせは、一度に複数のテーブルにアクセスすることも、同時にテーブル内の複数の行の処理を行う場合など、同じテーブルにアクセスすることも可能です。
一度に同一のテーブルまたは複数のテーブルの複数の行にアクセスする問い合わせは、<firstterm>結合</firstterm>問い合わせと呼ばれます。
例として、関連する都市の位置情報を気象データと一緒に表示したい場合が挙げられます。
それを行うためには、<structname>weather</>テーブルの各行の<structfield>city</>列と、<structname>cities</>テーブルの全ての行の<structfield>name</>列を比較し、両者の値が一致する行の組み合わせを選択しなければなりません。
    <note>
     <para>
<!--
      This  is only a conceptual model.  The join is usually performed
      in a more efficient manner than actually comparing each possible
      pair of rows, but this is invisible to the user.
-->
これは概念的なモデルでしかありません。
実際の結合は通常、1つひとつの行の組み合わせを比べるのではなく、もっと効率的な方法で行われます。
しかし、これはユーザからはわかりません。
     </para>
    </note>
<!--
    This would be accomplished by the following query:
-->
これは、以下の問い合わせによって行うことができます。

<programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>

   </para>

   <para>
<!--
    Observe two things about the result set:
-->
この結果から2つのことがわかります。
    <itemizedlist>
     <listitem>
      <para>
<!--
       There is no result row for the city of Hayward.  This is
       because there is no matching entry in the
       <structname>cities</structname> table for Hayward, so the join
       ignores the unmatched rows in the <structname>weather</> table.  We will see
       shortly how this can be fixed.
-->
Hayward市についての結果行はありません。
<structname>cities</structname>テーブルにはHaywardに一致する項目がなく、結合の際に<structname>weather</>テーブル内の一致しない行は無視されるからです。
これがどのようになされるのかを、簡単に見てみましょう。
      </para>
     </listitem>

     <listitem>
      <para>
<!--
       There are two columns containing the city name.  This is
       correct because the lists of columns from the
       <structname>weather</structname> and
       <structname>cities</structname> tables are concatenated.  In
       practice this is undesirable, though, so you will probably want
       to list the output columns explicitly rather than using
       <literal>*</literal>:
-->
都市名を持つ２つの列があります。
<structname>weather</structname>テーブルと<structname>cities</structname>テーブルからの列のリストが連結されているためこのようになります。
しかし実際には、これは望ましい結果ではないため、<literal>*</literal>を使わずに、明示的に出力列のリストを指定することになります。
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <formalpara>
<!--
    <title>Exercise:</title>
-->
    <title>練習:</title>

    <para>
<!--
     Attempt to determine the semantics of this query when the
     <literal>WHERE</literal> clause is omitted.
-->
<literal>WHERE</literal>句を省略した場合のこの問い合わせの意味を決定してください。
    </para>
   </formalpara>

   <para>
<!--
    Since the columns all had different names, the parser
    automatically found which table they belong to.  If there
    were duplicate column names in the two tables you'd need to
    <firstterm>qualify</> the column names to show which one you
    meant, as in:
-->
列はそれぞれ異なる名前ですので、パーサは自動的にどのテーブルの列かを見つけます。
2つのテーブルで列名が重複していた場合は、以下のようにどちらの列を表示させたいかを示すために列名を<firstterm>修飾</>しなければなりません。

<programlisting>
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
</programlisting>

<!--
    It is widely considered good style to qualify all column names
    in a join query, so that the query won't fail if a duplicate
    column name is later added to one of the tables.
-->
結合問い合わせではすべての列名を修飾する方式が優れているとよく考えられています。
テーブルのいずれかに後で重複する名前を持つ列が追加された場合に、問い合わせが失敗するからです。
   </para>

   <para>
<!--
    Join queries of the kind seen thus far can also be written in this
    alternative form:
-->
ここで示すような結合問い合わせは、以下のように別の形で表すことができます。

<programlisting>
SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);
</programlisting>

<!--
    This syntax is not as commonly used as the one above, but we show
    it here to help you understand the following topics.
-->
この構文は先の例よりも一般的に使用されるものではありませんが、以降の話題の理解を助けるためにここで示しています。
   </para>

   <para>
<!--
    <indexterm><primary>join</primary><secondary>outer</secondary></indexterm>
-->
    <indexterm><primary>結合</primary><secondary>外部</secondary></indexterm>

<!--
    Now we will figure out how we can get the Hayward records back in.
    What we want the query to do is to scan the
    <structname>weather</structname> table and for each row to find the
    matching <structname>cities</structname> row(s).  If no matching row is
    found we want some <quote>empty values</quote> to be substituted
    for the <structname>cities</structname> table's columns.  This kind
    of query is called an <firstterm>outer join</firstterm>.  (The
    joins we have seen so far are inner joins.)  The command looks
    like this:
-->
ここで、どのようにすればHaywardのレコードを得ることができるようになるのでしょうか。
実行したい問い合わせは、<structname>weather</structname>をスキャンし、各行に対して、<structname>cities</structname>行に一致するかを判断するものです。
一致しない行があった場合、<structname>cities</structname>テーブルの列の部分を何らかの<quote>空の値</quote>に置き換えたいのです。
この種の問い合わせは<firstterm>外部結合</firstterm>と呼ばれます
（これまで示してきた結合は内部結合です）。
以下のようなコマンドになります。

<programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</programlisting>

<!--
    This query is called a <firstterm>left outer
    join</firstterm> because the table mentioned on the left of the
    join operator will have each of its rows in the output at least
    once, whereas the table on the right will only have those rows
    output that match some row of the left table.  When outputting a
    left-table row for which there is no right-table match, empty (null)
    values are substituted for the right-table columns.
-->
この問い合わせは<firstterm>左外部結合</firstterm>と呼ばれます。
結合演算子の左側に指定したテーブルの各行が最低でも一度出力され、一方で、右側のテーブルでは左側のテーブルの行に一致するもののみが出力されるからです。
右側のテーブルに一致しない、左側のテーブルの行を出力する時、右側のテーブルの列は空の値（NULL）で置換されます。
   </para>

   <formalpara>
<!--
    <title>Exercise:</title>
-->
    <title>練習:</title>

    <para>
<!--
     There are also right outer joins and full outer joins.  Try to
     find out what those do.
-->
右外部結合や完全外部結合も存在します。
これらが何を行うかを考えてください。
    </para>
   </formalpara>

   <para>
<!--
    <indexterm><primary>join</primary><secondary>self</secondary></indexterm>
    <indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm>
-->
    <indexterm><primary>結合</primary><secondary>自己</secondary></indexterm>
    <indexterm><primary>別名</primary><secondary>問い合わせ内のテーブル名用の</secondary></indexterm>

<!--
    We can also join a table against itself.  This is called a
    <firstterm>self join</firstterm>.  As an example, suppose we wish
    to find all the weather records that are in the temperature range
    of other weather records.  So we need to compare the
    <structfield>temp_lo</> and <structfield>temp_hi</> columns of
    each <structname>weather</structname> row to the
    <structfield>temp_lo</structfield> and
    <structfield>temp_hi</structfield> columns of all other
    <structname>weather</structname> rows.  We can do this with the
    following query:
-->
テーブルを自分自身に対して結合させることができます。
これは<firstterm>自己結合</firstterm>と呼ばれます。
例として、他の気象データの気温範囲内にある気象データを全て取り出すことを考えます。
<structname>weather</structname>各行の<structfield>temp_lo</>と<structfield>temp_hi</>を、他の<structname>weather</structname>行の<structfield>temp_lo</structfield>と<structfield>temp_hi</structfield>列とを比較しなければなりません。
以下の問い合わせを使用して行うことができます。

<programlisting>
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo &lt; W2.temp_lo
    AND W1.temp_hi &gt; W2.temp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</programlisting>

<!--
    Here we have relabeled the weather table as <literal>W1</> and
    <literal>W2</> to be able to distinguish the left and right side
    of the join.  You can also use these kinds of aliases in other
    queries to save some typing, e.g.:
-->
ここで、結合の左側と右側を区別することができるように、weatherテーブルに<literal>W1</>と<literal>W2</>というラベルを付けています。
また、入力量を省くために、他の問い合わせでもこの種の別名を使用することができます。
以下に例を示します。
<programlisting>
SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;
</programlisting>
<!--
    You will encounter this style of abbreviating quite frequently.
-->
こういった形の省略はかなりよく行われます。
   </para>
  </sect1>


  <sect1 id="tutorial-agg">
<!--
   <title>Aggregate Functions</title>
-->
   <title>集約関数</title>

   <indexterm zone="tutorial-agg">
<!--
    <primary>aggregate function</primary>
-->
    <primary>集約関数</primary>
   </indexterm>

   <para>
<!--
    Like  most  other relational database products,
    <productname>PostgreSQL</productname> supports
    <firstterm>aggregate functions</>.
    An aggregate function computes a single result from multiple input rows.
    For example, there are aggregates to compute the
    <function>count</function>, <function>sum</function>,
    <function>avg</function> (average), <function>max</function> (maximum) and
    <function>min</function> (minimum) over a set of rows.
-->
他のほとんどのリレーショナルデータベース製品同様、<productname>PostgreSQL</productname>は<firstterm>集約関数</>をサポートします。
集約関数は複数の入力行から1つの結果を計算します。
例えば、行の集合に対して、<function>count</function>（総数）、<function>sum</function>（総和）、<function>avg</function>（平均）、<function>max</function>（最大）、<function>min</function>（最小）といった演算を行う集約があります。
   </para>

   <para>
<!--
    As an example, we can find the highest low-temperature reading anywhere
    with:
-->
例として、次のように全ての都市の最低気温から最も高い気温を求めることができます。

<programlisting>
SELECT max(temp_lo) FROM weather;
</programlisting>

<screen>
 max
-----
  46
(1 row)
</screen>
   </para>

   <para>
<!--
    <indexterm><primary>subquery</primary></indexterm>
-->
    <indexterm><primary>副問い合わせ</primary></indexterm>

<!--
    If we wanted to know what city (or cities) that reading occurred in,
    we might try:
-->
どの都市のデータなのかを知りたいとしたら、下記のような問い合わせを試行するかもしれません。

<programlisting>
<!--
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>WRONG</lineannotation>
-->
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>間違い</lineannotation>
</programlisting>

<!--
    but this will not work since the aggregate
    <function>max</function> cannot be used in the
    <literal>WHERE</literal> clause.  (This restriction exists because
    the <literal>WHERE</literal> clause determines which rows will be
    included in the aggregate calculation; so obviously it has to be evaluated
    before aggregate functions are computed.)
    However, as is often the case
    the query can be restated to accomplish the desired result, here
    by using a <firstterm>subquery</firstterm>:
-->
しかし、<function>max</function>集約を<literal>WHERE</literal>で使用することができませんので、このコマンドは動作しません
（<literal>WHERE</literal>句はどの行を集約処理に渡すのかを決定するものであり、したがって、集約関数の演算を行う前に評価されなければならないことは明らかです。
このためにこの制限があります）。
しかしたいていの場合、問い合わせを書き直すことで、意図した結果が得られます。
これには以下のような<firstterm>副問い合わせ</firstterm>を使用します。

<programlisting>
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
</programlisting>

<screen>
     city
---------------
 San Francisco
(1 row)
</screen>

<!--
    This is OK because the subquery is an independent computation
    that computes its own aggregate separately from what is happening
    in the outer query.
-->
副問い合わせは、外側の問い合わせで起こることとは別々に集約を計算する独立した演算ですので、この問い合わせは問題ありません。
   </para>

   <para>
    <indexterm><primary>GROUP BY</primary></indexterm>
    <indexterm><primary>HAVING</primary></indexterm>

<!--
    Aggregates are also very useful in combination with <literal>GROUP
    BY</literal> clauses.  For example, we can get the maximum low
    temperature observed in each city with:
-->
また、<literal>GROUP BY</literal>句と組み合わせた集約は非常に役に立ちます。
例えば、以下のコマンドで都市ごとに最低気温の最大値を求めることができます。

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)
</screen>

<!--
    which gives us one output row per city.  Each aggregate result is
    computed over the table rows matching that city.
    We can filter these grouped
    rows using <literal>HAVING</literal>:
-->
ここには都市ごとに1行の出力があります。
それぞれの集約結果は都市に一致するテーブル行全体に対する演算結果です。
以下のように、<literal>HAVING</literal>を使用すると、グループ化された行にフィルタをかけることができます。

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>

<screen>
  city   | max
---------+-----
 Hayward |  37
(1 row)
</screen>

<!--
    which gives us the same results for only the cities that have all
    <structfield>temp_lo</> values below 40.  Finally, if we only care about
    cities whose
    names begin with <quote><literal>S</literal></quote>, we might do:
-->
このコマンドは上と同じ計算を行うものですが、全ての<structfield>temp_lo</>の値が40未満の都市のみを出力します。
最後になりますが、<quote><literal>S</literal></quote>から始まる名前の都市のみを対象にしたい場合は、以下を行います。

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'<co id="co.tutorial-agg-like">
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>
   <calloutlist>
    <callout arearefs="co.tutorial-agg-like">
     <para>
<!--
      The <literal>LIKE</literal> operator does pattern matching and
      is explained in <xref linkend="functions-matching">.
-->
<literal>LIKE</literal>演算子はパターン一致を行います。これについては<xref linkend="functions-matching">で説明します。
     </para>
    </callout>
   </calloutlist>
   </para>

   <para>
<!--
    It is important to understand the interaction between aggregates and
    <acronym>SQL</acronym>'s <literal>WHERE</literal> and <literal>HAVING</literal> clauses.
    The fundamental difference between <literal>WHERE</literal> and
    <literal>HAVING</literal> is this: <literal>WHERE</literal> selects
    input rows before groups and aggregates are computed (thus, it controls
    which rows go into the aggregate computation), whereas
    <literal>HAVING</literal> selects group rows after groups and
    aggregates are computed.  Thus, the
    <literal>WHERE</literal> clause must not contain aggregate functions;
    it makes no sense to try to use an aggregate to determine which rows
    will be inputs to the aggregates.  On the other hand, the
    <literal>HAVING</literal> clause always contains aggregate functions.
    (Strictly speaking, you are allowed to write a <literal>HAVING</literal>
    clause that doesn't use aggregates, but it's seldom useful. The same
    condition could be used more efficiently at the <literal>WHERE</literal>
    stage.)
-->
集約と<acronym>SQL</acronym>の<literal>WHERE</literal>と<literal>HAVING</literal>句の間の相互作用を理解することが重要です。
<literal>WHERE</literal>と<literal>HAVING</literal>の基本的な違いを以下に記します。
<literal>WHERE</literal>は、グループや集約を演算する前に入力行を選択します（したがって、これはどの行を使用して集約演算を行うかを制御します）。
一方、<literal>HAVING</literal>は、グループと集約を演算した後に、グループ化された行を選択します。
したがって、<literal>WHERE</literal>句は集約関数を持つことはできません。
集約を使用して、どの行をその集約の入力にするのかを決定することは意味をなしません。
一方で、<literal>HAVING</literal>句は常に集約関数を持ちます
（厳密に言うと、集約を使用しない<literal>HAVING</literal>句を書くことはできますが、これは有用となることはほぼありません。
同じ条件は<literal>WHERE</literal>の段階でもっと効率良く使用できます）。
   </para>

   <para>
<!--
    In the previous example, we can apply the city name restriction in
    <literal>WHERE</literal>, since it needs no aggregate.  This is
    more efficient than adding the restriction to <literal>HAVING</literal>,
    because we avoid doing the grouping and aggregate calculations
    for all rows that fail the <literal>WHERE</literal> check.
-->
前の例では<literal>WHERE</literal>内に都市名制限を適用することができます。
集約を行う必要がないからです。
<literal>WHERE</literal>の検査で失敗する全ての行に対するグループ化や集約演算が行われませんので、<literal>HAVING</literal>に制限を追加するよりも効率的です。
   </para>
  </sect1>


  <sect1 id="tutorial-update">
<!--
   <title>Updates</title>
-->
   <title>更新</title>

   <indexterm zone="tutorial-update">
    <primary>UPDATE</primary>
   </indexterm>

   <para>
<!--
    You can update existing rows using the
    <command>UPDATE</command> command.
    Suppose you discover the temperature readings are
    all off by 2 degrees after November 28.  You can correct the
    data as follows:
-->
<command>UPDATE</command>コマンドを使用して、既存の行を更新することができます。
11月28日以降の全ての気温の読み取りが2度高くなっていることがわかったとします。
その場合、以下のコマンドによって、データを修正することができます。

<programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>

   <para>
<!--
    Look at the new state of the data:
-->
データの更新後の状態を確認します。
<programlisting>
SELECT * FROM weather;

     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
 Hayward       |      35 |      52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
  </sect1>

  <sect1 id="tutorial-delete">
<!--
   <title>Deletions</title>
-->
   <title>削除</title>

   <indexterm zone="tutorial-delete">
    <primary>DELETE</primary>
   </indexterm>

   <para>
<!--
    Rows can be removed from a table using the <command>DELETE</command>
    command.
    Suppose you are no longer interested in the weather of Hayward.
    Then you can do the following to delete those rows from the table:
-->
<command>DELETE</command>コマンドを使用してテーブルから行を削除することができます。
Haywardの気象を対象としなくなったとします。
その場合、以下のコマンドを使用して、テーブルから行を削除することができます。
<programlisting>
DELETE FROM weather WHERE city = 'Hayward';
</programlisting>

<!--
    All weather records belonging to Hayward are removed.
-->
Haywardに関する気象データは全て削除されました。

<programlisting>
SELECT * FROM weather;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>

   <para>
<!--
    One should be wary of statements of the form
-->
以下の形式の文には注意しなければなりません。
<synopsis>
DELETE FROM <replaceable>tablename</replaceable>;
</synopsis>

<!--
    Without a qualification, <command>DELETE</command> will
    remove  <emphasis>all</>  rows from the given table, leaving it
    empty.  The system will not request confirmation before
    doing this!
-->
条件がない場合、<command>DELETE</command>は指定したテーブルの<emphasis>全ての</>行を削除し、テーブルを空にします。
システムは削除前に確認を求めるようなことは行いません！
   </para>
  </sect1>

 </chapter>
